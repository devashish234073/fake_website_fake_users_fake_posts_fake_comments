const http = require('http');
const fs = require('fs');
const url = require('url');
var request = require('request');
let MODEL = "qwen3:1.7b";
const users = {};
const posts = {};
const friends = {};
const friendRequests = {};
if(process.argv.length > 2) {
    MODEL = process.argv[2];
}
console.log("Using model", MODEL);

// Simple LLM mock
const mockLLM = (prompt) => {
    return new Promise(resolve => {
        setTimeout(() => {
            if (prompt.includes('generate a post about')) {
                resolve(`This is a mock post generated by the LLM: ${prompt.replace('generate a post about', '')}`);
            } else {
                resolve(`LLM response to: ${prompt}`);
            }
        }, 500);
    });
};

let olderContent = "[]";
if (fs.existsSync("posts.json")) {
    olderContent = fs.readFileSync("posts.json", "utf-8");
}
let olderContentJson = JSON.parse(olderContent);

const messages = {};
const notifications = {};

// Track API call counts
const apiCallCounts = {};

const handleRequest = async (req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const path = parsedUrl.pathname;
    const query = parsedUrl.query;

    // Increment call count for this path
    if (path != "/ollama-prompt") {
        apiCallCounts[path] = (apiCallCounts[path] || 0) + 1;
    }

    if (path === '/') {
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end(fs.readFileSync('index.html'));
    } else if (path === '/api/call-counts') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ apiCallCounts }));
    } else if (path === '/login') {
        const user = query.user;
        const gender = query.gender || 'M';
        const profession = query.profession || 'Developer';
        if (user) {
            if (!users[user]) {
                users[user] = { name: user, gender, profession };
                posts[user] = [];
                friends[user] = [];
                friendRequests[user] = [];
            }
            // Redirect the user back to the main page
            res.writeHead(302, {
                'Location': `/?user=${user}&gender=${gender}&profession=${profession}`
            });
            res.end();
        } else {
            res.writeHead(400, { 'Content-Type': 'text/plain' });
            res.end('User parameter is missing');
        }
    } else if (path === '/search') {
        const queryTerm = query.query.toLowerCase();
        const currentUser = query.user;
        const results = Object.keys(users).filter(u =>
            u.toLowerCase().startsWith(queryTerm) && u !== currentUser && !friends[currentUser].includes(u)
        );
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ results, apiCallCounts }));
    } else if (path === '/friend-request') {
        const { from, to } = query;
        console.log(`Friend request from ${from} to ${to}`);
        if (from !== to && users[to] && !friendRequests[to].includes(from) && !friends[from].includes(to)) {
            friendRequests[to].push(from);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Friend request sent', apiCallCounts }));
        } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Could not send friend request', apiCallCounts }));
        }
    } else if (path === '/get-friend-requests') {
        const { user } = query;
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ requests: friendRequests[user] || [], apiCallCounts }));
    } else if (path === '/accept-friend-request') {
        const { user, requester } = query;
        console.log(`Accepting friend request from ${requester} to ${user}`);
        const index = friendRequests[user].indexOf(requester);
        if (index > -1) {
            friendRequests[user].splice(index, 1);
            if (!friends[user].includes(requester)) friends[user].push(requester);
            if (!friends[requester].includes(user)) friends[requester].push(user);
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Friend request accepted', apiCallCounts }));
        } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Invalid request', apiCallCounts }));
        }
    } else if (path === '/get-friends') {
        const { user } = query;
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ friends: friends[user] || [], apiCallCounts }));
    } else if (path === '/create-post') {
        const { user, content } = query;
        if (users[user] && content) {
            posts[user].push({ content, timestamp: new Date().toISOString(), comments: [] });
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Post created', apiCallCounts }));
        } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Invalid post data', apiCallCounts }));
        }
    } else if (path === '/get-feed') {
        const { user } = query;
        const feedPosts = [];
        const userFriends = friends[user] || [];
        userFriends.forEach(friend => {
            if (posts[friend]) {
                posts[friend].forEach(post => feedPosts.push({ user: friend, ...post }));
            }
        });
        // Sort by number of comments (descending), then by timestamp (descending) as tiebreaker
        feedPosts.sort((a, b) => {
            const commentsA = Array.isArray(a.comments) ? a.comments.length : 0;
            const commentsB = Array.isArray(b.comments) ? b.comments.length : 0;
            if (commentsB !== commentsA) {
                return commentsB - commentsA;
            }
            return new Date(b.timestamp) - new Date(a.timestamp);
        });
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ feed: feedPosts, apiCallCounts }));
    } else if (path === '/llm-prompt') {
        const { prompt } = query;
        if (prompt) {
            try {
                const llmResponse = await mockLLM(prompt);
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ response: llmResponse, apiCallCounts }));
            } catch (error) {
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'LLM request failed', apiCallCounts }));
            }
        } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Prompt is missing', apiCallCounts }));
        }
    } else if (path === '/send-message') {
        const { from, to, content } = query;
        if (users[from] && users[to] && content) {
            // Ensure a chat array exists for both users
            if (!messages[from]) messages[from] = {};
            if (!messages[to]) messages[to] = {};
            if (!messages[from][to]) messages[from][to] = [];
            if (!messages[to][from]) messages[to][from] = [];

            const message = { from, content, timestamp: new Date().toISOString() };
            messages[from][to].push(message);
            messages[to][from].push(message); // Store for both users
            console.log("messages after sending", messages);

            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Message sent', apiCallCounts }));
        } else {
            res.writeHead(400, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Invalid message data', apiCallCounts }));
        }
    } else if (path === '/get-messages') {
        const { user, friend } = query;
        console.log("all messages", messages);
        const chat = (messages[user] && messages[user][friend]) || [];
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ chat, apiCallCounts }));
    } else if (path === '/add-comment') {
        const { postId, user, comment } = query;
        const postOwner = Object.keys(posts).find(owner =>
            posts[owner].findIndex(p => p.timestamp === postId) !== -1
        );

        if (postOwner) {
            const postIndex = posts[postOwner].findIndex(p => p.timestamp === postId);
            posts[postOwner][postIndex].comments.push({ user, comment, timestamp: new Date().toISOString() });

            // Add notification logic
            if (!notifications[postOwner]) notifications[postOwner] = [];
            notifications[postOwner].push({
                type: 'comment',
                message: `${user} commented on your post.`,
                timestamp: new Date().toISOString()
            });

            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Comment added', apiCallCounts }));
        } else {
            res.writeHead(404, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ message: 'Post not found', apiCallCounts }));
        }
    } else if (path === '/get-my-data') {
        const { user } = query;
        const userPosts = (posts[user] || []).map(post => {
            // Return the post object with all its properties, including comments
            return {
                content: post.content,
                timestamp: post.timestamp,
                comments: post.comments || []
            };
        });
        const userNotifications = notifications[user] || [];
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
            myPosts: userPosts,
            notifications: userNotifications,
            apiCallCounts
        }));
    } else if (path === '/ollama-prompt') {
        if (req.method === 'POST') {
            let body = '';
            req.on('data', chunk => {
                body += chunk.toString();
            });
            req.on('end', async () => {
                let { prompt, gender, profession, type } = JSON.parse(body);
                prompt = prompt.split("\n").join(" ").split("\"").join("'");
                apiCallCounts[path + "-" + type] = (apiCallCounts[path + "-" + type] || 0) + 1;
                var request = require('request');
                var options = {
                    'method': 'POST',
                    'url': 'http://localhost:11434/api/generate',
                    'headers': {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        "model": MODEL,
                        "prompt": prompt + ". Do not use any special characters other than # in the response.",
                        "stream": false,
                        "think": false
                    })

                };
                request(options, function (error, response) {
                    if (error) {
                        console.error('Ollama request failed:', error);
                        res.writeHead(500, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ error: 'LLM request failed', apiCallCounts }));
                    } else {
                        //console.log("raw from llm", response.body);
                        let llmResp = JSON.parse(response.body).response;
                        console.log("from llm", llmResp);
                        res.writeHead(200, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify({ response: llmResp, apiCallCounts }));
                    }
                });
            });
        };
    } else if (path === '/ollama-prompt-old') {
        if (req.method === 'POST') {
            let body = '';
            req.on('data', chunk => {
                body += chunk.toString();
            });
            req.on('end', async () => {
                let { prompt, gender, profession, type } = JSON.parse(body);
                prompt = prompt.split("\n").join(" ").split("\"").join("'");
                apiCallCounts[path + "-" + type] = (apiCallCounts[path + "-" + type] || 0) + 1;
                try {
                    const ollamaResponse = await new Promise((resolve, reject) => {
                        const postData = JSON.stringify({
                            model: MODEL,
                            prompt: prompt + ". Do not use any special characters other than # in the response.",
                            stream: false,
                            think: false
                        });

                        const options = {
                            hostname: 'localhost',
                            port: 11434,
                            path: '/api/generate',
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Content-Length': postData.length
                            }
                        };

                        const ollamaReq = http.request(options, (ollamaRes) => {
                            let data = '';
                            ollamaRes.on('data', (chunk) => {
                                data += chunk;
                            });
                            ollamaRes.on('end', () => {
                                try {
                                    const jsonResponse = JSON.parse(data);
                                    let fromLLM = jsonResponse.response;
                                    console.log("response from llm", data);
                                    olderContentJson.push({ prompt, response: fromLLM, gender, profession });
                                    resolve(fromLLM);
                                } catch (e) {
                                    reject(new Error('Failed to parse Ollama response ' + e.message));
                                }
                            });
                        });

                        ollamaReq.on('error', (e) => {
                            console.error('Ollama request error:', e);
                            reject(e);
                        });

                        console.log("request sent to llm", postData);
                        ollamaReq.write(postData);
                        ollamaReq.end();
                    });

                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ response: ollamaResponse, apiCallCounts }));

                } catch (error) {
                    console.error('Ollama request failed:', error);
                    res.writeHead(500, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'LLM request failed', apiCallCounts }));
                }
            });
        } else {
            res.writeHead(405, { 'Content-Type': 'text/plain' });
            res.end('Method Not Allowed');
        }
    }
};

setInterval(() => {
    fs.writeFileSync("posts.json", JSON.stringify(olderContentJson, null, 2));
}, 60000);

const server = http.createServer(handleRequest);

const PORT = 8080;
server.listen(PORT, () => {
    console.log(`Server is running at http://localhost:${PORT}`);
});